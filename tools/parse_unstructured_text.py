import asyncio
import json
from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
from autogen_agentchat.messages import TextMessage
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.conditions import TextMentionTermination, MaxMessageTermination
from agents.prompts.unstructured_text_parser_message import UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE
from typing import List, Dict

async def parse_unstructured_text(unstructured_text: str, model_client, code_executor_instance) -> str:
    """
    Parses unstructured text by orchestrating a conversational and self-correcting
    process between a code-writing agent and a code-executing agent.

    Args:
        unstructured_text (str): The raw text extracted from a PDF.
        model_client: The language model client for the code-writing agent.
        code_executor_instance: The configured Docker code executor instance.

    Returns:
        str: A JSON string of the extracted transactions, or an error JSON.
    """
    # 1. Define the agents for the conversational sub-task
    code_writer = AssistantAgent(
        name="Code_Writer",
        model_client=model_client,
        system_message=UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE,
    )

    # CodeExecutorAgent should not have a model_client when used with another agent
    # It will execute code blocks generated by the code_writer
    code_executor_agent = CodeExecutorAgent(
        name="Code_Executor",
        code_executor=code_executor_instance
    )

    # 2. Create a team with RoundRobinGroupChat and termination conditions
    termination_condition = MaxMessageTermination(50) | TextMentionTermination("successfully produced the expected JSON output")
    
    team = RoundRobinGroupChat([code_writer, code_executor_agent], termination_condition=termination_condition)

    # 3. Create the initial task message - this should be sent to the code_writer
    task_message = TextMessage(
        content=f"Your task is to parse the following text and extract all financial transactions. "
                f"Write Python code to accomplish this task. The code should output a JSON array of transactions. "
                f"Follow your system instructions to plan, write, and refine your code until you succeed.\n\n"
                f"--- TEXT TO PARSE ---\n{unstructured_text}\n---",
        source="user"  # Changed from code_executor_agent.name to "user"
    )

    # 4. Run the conversation using the team with termination conditions
    chat_history = []
    print("\n--- Code Writer and Executor Conversation ---")
    max_messages = 50  # Prevent infinite loops
    json_found = False
    consecutive_no_code_messages = 0
    
    try:
        async for message in team.run_stream(task=task_message):
            chat_history.append(message)
            
            # Print the content of each message in the conversation
            if hasattr(message, 'source') and hasattr(message, 'content'):
                print(f"Speaker: {message.source}")
                print(f"Content:\n{message.content}")
                print("-" * 50)
                
                # Check for JSON in the message
                content = getattr(message, 'content', '')
                if isinstance(content, str):
                    # Look for JSON array
                    start_index = content.find('[')
                    end_index = content.rfind(']')
                    if start_index != -1 and end_index != -1 and start_index < end_index:
                        json_string = content[start_index:end_index+1]
                        try:
                            json.loads(json_string)
                            print(f"\nüéØ Valid JSON found in message from {message.source}")
                            json_found = True
                        except json.JSONDecodeError:
                            pass
                    
                    # Check termination conditions
                    if message.source == "Code_Executor" and "No code blocks found" in content:
                        consecutive_no_code_messages += 1
                        print(f"Consecutive code messages: {consecutive_no_code_messages}")
                    else:
                        consecutive_no_code_messages = 0
                
                # Stop if we have JSON and the conversation is stuck
                if json_found and consecutive_no_code_messages >= 5:
                    print("\n‚úÖ Terminating: Found valid JSON and conversation is requesting more code unnecessarily")
                    break
                    
                # Stop if we hit max messages
                if len(chat_history) >= max_messages:
                    print(f"\n‚ö†Ô∏è Terminating: Hit maximum message limit of {max_messages}")
                    break
                    
    except Exception as e:
        print(f"Error during conversation: {e}")
        return json.dumps({"error": f"Conversation failed: {str(e)}"})

    # 5. Extract the final result from the collected chat history
    # Search for the message containing the final JSON from the end of the history.
    for message in reversed(chat_history):
        content = getattr(message, 'content', None)
        if isinstance(content, str):
            # Look for JSON array in the content
            start_index = content.find('[')
            end_index = content.rfind(']')
            if start_index != -1 and end_index != -1 and start_index < end_index:
                json_string = content[start_index:end_index+1]
                try:
                    # Validate that it's proper JSON
                    json.loads(json_string)
                    print("\n--- Generated JSON ---")
                    print(json_string)
                    print("-" * 50)
                    return json_string
                except json.JSONDecodeError:
                    # If parsing fails, continue to the next message
                    continue
                    
            # Also check for JSON objects (in case the output is a single object)
            start_index = content.find('{')
            end_index = content.rfind('}')
            if start_index != -1 and end_index != -1 and start_index < end_index:
                json_string = content[start_index:end_index+1]
                try:
                    # Validate that it's proper JSON
                    json.loads(json_string)
                    print("\n--- Generated JSON ---")
                    print(json_string)
                    print("-" * 50)
                    return json_string
                except json.JSONDecodeError:
                    continue

    print("\n--- Error: Could not extract valid JSON ---")
    return json.dumps({"error": "Could not extract valid JSON from the final message."})

# # import asyncio
# # import json
# # from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
# # from autogen_agentchat.messages import TextMessage
# # from autogen_agentchat.teams import RoundRobinGroupChat
# # from agents.prompts.unstructured_text_parser_message import UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE
# # from typing import List, Dict

# # async def parse_unstructured_text(unstructured_text: str, model_client, code_executor_instance) -> str:
# #     """
# #     Parses unstructured text by orchestrating a conversational and self-correcting
# #     process between a code-writing agent and a code-executing agent.

# #     Args:
# #         unstructured_text (str): The raw text extracted from a PDF.
# #         model_client: The language model client for the code-writing agent.
# #         code_executor_instance: The configured Docker code executor instance.

# #     Returns:
# #         str: A JSON string of the extracted transactions, or an error JSON.
# #     """
# #     # 1. Define the agents for the conversational sub-task
# #     code_writer = AssistantAgent(
# #         name="Code_Writer",
# #         model_client=model_client,
# #         system_message=UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE,
# #     )

# #     # CodeExecutorAgent should not have a model_client when used with another agent
# #     # It will execute code blocks generated by the code_writer
# #     code_executor_agent = CodeExecutorAgent(
# #         name="Code_Executor",
# #         code_executor=code_executor_instance
# #     )

# #     # 2. Create a team with RoundRobinGroupChat for proper conversation flow
# #     team = RoundRobinGroupChat([code_writer, code_executor_agent])

# #     # 3. Create the initial task message - this should be sent to the code_writer
# #     task_message = TextMessage(
# #         content=f"Your task is to parse the following text and extract all financial transactions. "
# #                 f"Write Python code to accomplish this task. The code should output a JSON array of transactions. "
# #                 f"Follow your system instructions to plan, write, and refine your code until you succeed.\n\n"
# #                 f"--- TEXT TO PARSE ---\n{unstructured_text}\n---",
# #         source="user"  # Changed from code_executor_agent.name to "user"
# #     )

# #     # 4. Run the conversation using the team
# #     chat_history = []
# #     print("\n--- Code Writer and Executor Conversation ---")
    
# #     try:
# #         async for message in team.run_stream(task=task_message):
# #             chat_history.append(message)
# #             # Print the content of each message in the conversation
# #             if hasattr(message, 'source') and hasattr(message, 'content'):
# #                 print(f"Speaker: {message.source}")
# #                 print(f"Content:\n{message.content}")
# #                 print("-" * 50)
# #     except Exception as e:
# #         print(f"Error during conversation: {e}")
# #         return json.dumps({"error": f"Conversation failed: {str(e)}"})

# #     # 5. Extract the final result from the collected chat history
# #     # Search for the message containing the final JSON from the end of the history.
# #     for message in reversed(chat_history):
# #         content = getattr(message, 'content', None)
# #         if isinstance(content, str):
# #             # Look for JSON array in the content
# #             start_index = content.find('[')
# #             end_index = content.rfind(']')
# #             if start_index != -1 and end_index != -1 and start_index < end_index:
# #                 json_string = content[start_index:end_index+1]
# #                 try:
# #                     # Validate that it's proper JSON
# #                     json.loads(json_string)
# #                     print("\n--- Generated JSON ---")
# #                     print(json_string)
# #                     print("-" * 50)
# #                     return json_string
# #                 except json.JSONDecodeError:
# #                     # If parsing fails, continue to the next message
# #                     continue
                    
# #             # Also check for JSON objects (in case the output is a single object)
# #             start_index = content.find('{')
# #             end_index = content.rfind('}')
# #             if start_index != -1 and end_index != -1 and start_index < end_index:
# #                 json_string = content[start_index:end_index+1]
# #                 try:
# #                     # Validate that it's proper JSON
# #                     json.loads(json_string)
# #                     print("\n--- Generated JSON ---")
# #                     print(json_string)
# #                     print("-" * 50)
# #                     return json_string
# #                 except json.JSONDecodeError:
# #                     continue

# #     print("\n--- Error: Could not extract valid JSON ---")
# #     return json.dumps({"error": "Could not extract valid JSON from the final message."})


# # # import asyncio
# # # import json
# # # from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
# # # from autogen_agentchat.messages import TextMessage
# # # from agents.prompts.unstructured_text_parser_message import UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE
# # # from typing import List, Dict

# # # async def parse_unstructured_text(unstructured_text: str, model_client, code_executor_instance) -> str:
# # #     """
# # #     Parses unstructured text by orchestrating a conversational and self-correcting
# # #     process between a code-writing agent and a code-executing agent.

# # #     Args:
# # #         unstructured_text (str): The raw text extracted from a PDF.
# # #         model_client: The language model client for the code-writing agent.
# # #         code_executor_instance: The configured Docker code executor instance.

# # #     Returns:
# # #         str: A JSON string of the extracted transactions, or an error JSON.
# # #     """
# # #     # 1. Define the agents for the conversational sub-task
# # #     code_writer = AssistantAgent(
# # #         name="Code_Writer",
# # #         model_client=model_client,
# # #         system_message=UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE,
# # #     )

# # #     code_executor_agent = CodeExecutorAgent(
# # #         name="Code_Executor",
# # #         code_executor=code_executor_instance
# # #     )

# # #     # 2. Create the initial task message
# # #     task_message = TextMessage(
# # #         content=f"Your task is to parse the following text and extract all financial transactions. "
# # #                 f"Follow your system instructions to plan, write, and refine your code until you succeed.\n\n"
# # #                 f"--- TEXT TO PARSE ---\n{unstructured_text}\n---",
# # #         recipient=code_writer,
# # #         source=code_executor_agent.name
# # #     )

# # #     # 3. Run the conversation using the modern streaming method
# # #     chat_history = []
# # #     print("\n--- Code Writer and Executor Conversation ---")
# # #     async for message in code_executor_agent.run_stream(
# # #         task=task_message
# # #     ):
# # #         chat_history.append(message)
# # #         # Print the content of each message in the conversation
# # #         print(f"Speaker: {message.source}")
# # #         print(f"Content:\n{message.content}")
# # #         print("-" * 50)

# # #     # 4. Extract the final result from the collected chat history
# # #     # Search for the message containing the final JSON from the end of the history.
# # #     for message in reversed(chat_history):
# # #         content = getattr(message, 'content', None)
# # #         if isinstance(content, str):
# # #             # Find the start and end of the JSON block
# # #             start_index = content.find('[')
# # #             end_index = content.rfind(']')
# # #             if start_index != -1 and end_index != -1 and start_index < end_index:
# # #                 json_string = content[start_index:end_index+1]
# # #                 try:
# # #                     # Validate that it's proper JSON
# # #                     json.loads(json_string)
# # #                     print("\n--- Generated JSON ---")
# # #                     print(json_string)
# # #                     print("-" * 50)
# # #                     return json_string
# # #                 except json.JSONDecodeError:
# # #                     # If parsing fails, continue to the next message
# # #                     continue

# # #     print("\n--- Error: Could not extract valid JSON ---")
# # #     return json.dumps({"error": "Could not extract valid JSON from the final message."})

# # # # import asyncio
# # # # import json
# # # # from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
# # # # from autogen_agentchat.messages import TextMessage
# # # # from agents.prompts.unstructured_text_parser_message import UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE
# # # # from typing import List, Dict

# # # # async def parse_unstructured_text(unstructured_text: str, model_client, code_executor_instance) -> str:
# # # #     """
# # # #     Parses unstructured text by orchestrating a conversational and self-correcting
# # # #     process between a code-writing agent and a code-executing agent.

# # # #     Args:
# # # #         unstructured_text (str): The raw text extracted from a PDF.
# # # #         model_client: The language model client for the code-writing agent.
# # # #         code_executor_instance: The configured Docker code executor instance.

# # # #     Returns:
# # # #         str: A JSON string of the extracted transactions, or an error JSON.
# # # #     """
# # # #     # 1. Define the agents for the conversational sub-task
# # # #     code_writer = AssistantAgent(
# # # #         name="Code_Writer",
# # # #         model_client=model_client,
# # # #         system_message=UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE,
# # # #     )

# # # #     code_executor_agent = CodeExecutorAgent(
# # # #         name="Code_Executor",
# # # #         code_executor=code_executor_instance
# # # #     )

# # # #     # 2. Create the initial task message
# # # #     task_message = TextMessage(
# # # #         content=f"Your task is to parse the following text and extract all financial transactions. "
# # # #                 f"Follow your system instructions to plan, write, and refine your code until you succeed.\n\n"
# # # #                 f"--- TEXT TO PARSE ---\n{unstructured_text}\n---",
# # # #         recipient=code_writer,
# # # #         source=code_executor_agent.name
# # # #     )

# # # #     # 3. Run the conversation using the modern streaming method
# # # #     chat_history = []
# # # #     async for message in code_executor_agent.run_stream(
# # # #         task=task_message
# # # #     ):
# # # #         chat_history.append(message)

# # # #     # 4. Extract the final result from the collected chat history
# # # #     # Search for the message containing the final JSON from the end of the history.
# # # #     for message in reversed(chat_history):
# # # #         if isinstance(getattr(message, 'content', None), str) and "TERMINATE" in message.content:
# # # #             try:
# # # #                 # The JSON is everything before the "TERMINATE" keyword
# # # #                 json_string = message.content.split("TERMINATE")[0].strip()
# # # #                 json.loads(json_string)  # Validate that it's proper JSON
# # # #                 return json_string
# # # #             except (json.JSONDecodeError, IndexError):
# # # #                 continue
    
# # # #     return json.dumps({"error": "Could not extract valid JSON from the final message."})



# # # # # import asyncio
# # # # # import json
# # # # # from autogen_agentchat.agents import AssistantAgent, CodeExecutorAgent
# # # # # from autogen_agentchat.messages import TextMessage
# # # # # from agents.prompts.unstructured_text_parser_message import UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE
# # # # # from typing import List, Dict

# # # # # async def parse_unstructured_text(unstructured_text: str, model_client, code_executor_instance) -> str:
# # # # #     """
# # # # #     Parses unstructured text by orchestrating a conversational and self-correcting
# # # # #     process between a code-writing agent and a code-executing agent.

# # # # #     Args:
# # # # #         unstructured_text (str): The raw text extracted from a PDF.
# # # # #         model_client: The language model client for the code-writing agent.
# # # # #         code_executor_instance: The configured Docker code executor instance.

# # # # #     Returns:
# # # # #         str: A JSON string of the extracted transactions, or an error JSON.
# # # # #     """
# # # # #     # 1. Define the agents for the conversational sub-task
# # # # #     code_writer = AssistantAgent(
# # # # #         name="Code_Writer",
# # # # #         model_client=model_client,
# # # # #         system_message=UNSTRUCTURED_TEXT_PARSER_SYSTEM_MESSAGE,
# # # # #     )

# # # # #     # Use the CodeExecutorAgent as you suggested. It will initiate the chat and execute code.
# # # # #     code_executor_agent = CodeExecutorAgent(
# # # # #         name="Code_Executor",
# # # # #         code_executor=code_executor_instance
# # # # #     )

# # # # #     # 2. Create the initial task message
# # # # #     task_message = TextMessage(
# # # # #         content=f"Your task is to parse the following text and extract all financial transactions. "
# # # # #                 f"Follow your system instructions to plan, write, and refine your code until you succeed.\n\n"
# # # # #                 f"--- TEXT TO PARSE ---\n{unstructured_text}\n---",
# # # # #         recipient=code_writer,
# # # # #         source=code_executor_agent.name
# # # # #     )

# # # # #     # 3. Run the conversation using the modern streaming method
# # # # #     chat_history: List[Dict] = []
# # # # #     async for message in code_executor_agent.run_stream(
# # # # #         # recipient=code_writer,
# # # # #         task=task_message
# # # # #     ):
# # # # #         chat_history.append(message)

# # # # #     # 4. Extract the final result from the collected chat history
# # # # #     if not chat_history or len(chat_history) < 2:
# # # # #         return json.dumps({"error": "Code execution conversation failed."})

# # # # #     # The final JSON is in the content of the message from the code_writer
# # # # #     # which is the second to last message in the history.
# # # # #     final_message = chat_history[-2].content
# # # # #     print(final_message)
    
# # # # #     try:
# # # # #         # The JSON is everything before the "TERMINATE" keyword
# # # # #         json_string = final_message.split("TERMINATE")[0].strip()
# # # # #         json.loads(json_string) # Validate that it's proper JSON
# # # # #         return json_string
# # # # #     except (json.JSONDecodeError, IndexError):
# # # # #         return json.dumps({"error": "Could not extract valid JSON from the final message."})



