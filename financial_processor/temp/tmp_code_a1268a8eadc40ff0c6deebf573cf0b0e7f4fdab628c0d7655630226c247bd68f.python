import re
import json

def parse_amount(s):
    s = s.strip().replace(',', '')
    negative = False
    if s.startswith('(') and s.endswith(')'):
        negative = True
        s = s[1:-1]
    elif s.startswith('-'):
        negative = True
        s = s[1:]
    try:
        val = float(s)
        if negative:
            val = -val
        return abs(val)
    except Exception:
        return None

def find_block(block_title, lines):
    start, end = None, None
    for i, line in enumerate(lines):
        if block_title.lower() in line.strip().lower():
            start = i
            break
    if start is not None:
        for j in range(start+1, len(lines)):
            if lines[j].strip() == '' and (j == len(lines)-1 or lines[j+1].strip() == ''):
                end = j
                break
            # Stop at next section heading if any
            elif re.match(r'^[A-Z][A-Za-z ]+:$', lines[j].strip()):
                end = j
                break
        if end is None:
            end = len(lines)
    return (start, end)

def extract_cardholders(lines):
    cardholder_blocks = []
    cardholder_names = []
    current_name = None
    current_indices = []
    for idx, line in enumerate(lines):
        # Cardholder summary block
        m = re.match(r"^([A-Z '\-]+)[ ]+$", line.strip())
        if m:
            # Capital letter name alone, likely cardholder header, but skip general headers like SUMMARY etc
            likely_name = m.group(1).strip()
            if len(likely_name.split())>=2 and not any(kw in likely_name for kw in ['SUMMARY', 'DETAILS', 'TOTALS', 'ACCOUNT', 'PAYMENT', 'TRANSACTIONS']):
                if current_name is not None and current_indices:
                    cardholder_blocks.append((current_name, current_indices))
                current_name = likely_name
                current_indices = []
        # Look for lines like 'Card ending in 1234 - NAME'
        m = re.match(r'Card (?:number|ending in) (\d{4,})\s*-\s*(.+)', line.strip())
        if m:
            name = m.group(2).strip()
            if current_name is not None and current_indices:
                cardholder_blocks.append((current_name, current_indices))
            current_name = name
            current_indices = []
        if current_name:
            current_indices.append(idx)
    if current_name is not None and current_indices:
        cardholder_blocks.append((current_name, current_indices))
    # Clean up block indices: ensure they include only lines belonging to this cardholder
    names_found = []
    seen = set()
    for cn, idxs in cardholder_blocks:
        n = cn.title().strip()
        if n and n not in seen:
            names_found.append(n)
            seen.add(n)
    return names_found

def line_is_transaction(line):
    # Expects line starting with two dates MM/DD or M/D
    # e.g. 03/12 03/14 Store Name  XX.XX
    pat = r'\b(\d{1,2}/\d{1,2})\s+(\d{1,2}/\d{1,2})\s+(.+?)\s+([-\(\)\d,\.]+)\s*$'
    return re.match(pat, line.strip())

def extract_transactions_for_cardholder(lines, idx_range):
    txns = []
    pat = r'\b(\d{1,2}/\d{1,2})\s+(\d{1,2}/\d{1,2})\s+(.+?)\s+([-\(\)\d,\.]+)\s*$' # sale_date, post_date, desc, amt
    for idx in idx_range:
        line = lines[idx]
        m = re.match(pat, line.strip())
        if m:
            sale_date, post_date, desc, amt = m.groups()
            amt_val = parse_amount(amt)
            if amt_val is not None:
                txns.append({
                    'sale_date': sale_date,
                    'post_date': post_date,
                    'description': desc.strip(),
                    'amount': amt_val
                })
    return txns

def extract_bank_name(lines):
    # First non-empty line probably bank name, avoid known section/keyword lines
    for line in lines:
        if line.strip() and not any(line.strip().startswith(x) for x in ['Account', 'Statement', 'Date', 'Page', 'Summary']):
            return line.strip()
    return ''

def extract_summary(lines):
    summary = {
        'bank_name': '',
        "total_transactions": 0,
        "total_amount": 0.0,
        "previous_balance": 0.0,
        "payments": 0.0,
        "credits": 0.0,
        "purchases": 0.0,
        "cash_advances": 0.0,
        "fees": 0.0,
        "interest": 0.0,
        "new_balance": 0.0,
        "rewards_balance": 0.0,
        "available_credit_limit": 0.0,
    }
    # Find 'Account Summary' block
    start, end = find_block('Account Summary', lines)
    if start is not None:
        block = lines[start:end]
        for line in block:
            # Map possible summary labels on one-by-one
            field_maps = [
                ('Previous Balance', 'previous_balance'),
                ('Payments', 'payments'),
                ('Credits', 'credits'),
                ('Purchases', 'purchases'),
                ('Cash Advances', 'cash_advances'),
                ('Fees', 'fees'),
                ('Interest', 'interest'),
                ('New Balance', 'new_balance'),
                ('Available Credit Limit', 'available_credit_limit'),
                ('Rewards Balance', 'rewards_balance'),
                ('Total Transactions', 'total_transactions'),
                ('Total Amount', 'total_amount'),
            ]
            for k, mapped in field_maps:
                m = re.match(rf'{k}\s+([-\(\)\d,\.]+)', line.strip())
                if m:
                    val = parse_amount(m.group(1))
                    if mapped in ['total_transactions']:
                        try:
                            summary[mapped] = int(val)
                        except: pass
                    else:
                        summary[mapped] = val
    return summary

def extract_transactions_by_cardholder(lines, cardholder_names):
    txns = {}
    # Map each cardholder to block indices
    matches = []
    for name in cardholder_names:
        mat = None
        for i, l in enumerate(lines):
            # Start of cardholder section
            if name.upper() in l.strip().upper():
                mat = i
                break
        matches.append(mat)
    rngs = []
    for i in range(len(matches)):
        if matches[i] is not None:
            start = matches[i]
            end = matches[i+1] if i+1<len(matches) and matches[i+1] is not None else len(lines)
            rngs.append(range(start, end))
        else:
            rngs.append(range(0, 0))
    for idx, name in enumerate(cardholder_names):
        txns[name] = extract_transactions_for_cardholder(lines, rngs[idx])
    return txns

with open('statement.txt', encoding='utf-8') as f:
    lines = [l.rstrip('\n') for l in f]

bank_name = extract_bank_name(lines)
summary = extract_summary(lines)
if not summary['bank_name']:
    summary['bank_name'] = bank_name

cardholder_names = extract_cardholders(lines)
transactions_by_cardholder = extract_transactions_by_cardholder(lines, cardholder_names)

parsed = {
    'transactions_by_cardholder': transactions_by_cardholder,
    'summary': summary
}
print(json.dumps(parsed, ensure_ascii=False))
